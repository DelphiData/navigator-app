export default {
  async fetch(req, env) {
    // CORS for your Pages site
    const origin = req.headers.get("Origin") || "";
    const allowOrigin = origin && /github\.io$/.test(new URL(origin).hostname) ? origin : "*";
    const cors = {
      "Access-Control-Allow-Origin": allowOrigin,
      "Access-Control-Allow-Headers": "content-type",
      "Access-Control-Allow-Methods": "GET,POST,OPTIONS"
    };
    if (req.method === "OPTIONS") return new Response(null, { headers: cors });

    try {
      const url = new URL(req.url);
      if (url.pathname === "/health") return json({ ok: true }, cors);

      if (url.pathname === "/orgs") {
        const orgs = await getJson(`${env.DATA_BASE_URL}/navigatorOrgs.json`);
        return json({ orgs }, cors);
      }

      if (url.pathname === "/suggest" && req.method === "POST") {
        const body = await req.json();
        const { orgName, pcpOnRecord, snippet } = body || {};
        if (!orgName || !snippet) return bad("orgName and snippet are required", cors);

        // Load public data generated by your Pages repo
        const [orgs, templates, rulesExpanded, rules] = await Promise.all([
          getJson(`${env.DATA_BASE_URL}/navigatorOrgs.json`),
          getJson(`${env.DATA_BASE_URL}/commsTemplates.json`),
          getJson(`${env.DATA_BASE_URL}/rulesExpanded.json`).catch(() => []),
          getJson(`${env.DATA_BASE_URL}/rulesLibrary.json`)
        ]);

        const org = (orgs || []).find(o => o.OrgName === orgName) || null;

        // Build the structured task for the model
        const task = {
          org: {
            name: org?.OrgName || orgName,
            allowsFax: !!org?.AllowsFax,
            specialists: org?.SpecialistsAvailable || []
          },
          pcpOnRecord: !!pcpOnRecord,
          snippet,
          rules: (rulesExpanded && rulesExpanded.length ? rulesExpanded : rules),
          templates
        };

        const toolSchema = {
          type: "object",
          properties: {
            chosenRule: {
              type: "object",
              properties: {
                RuleID: { type: "string" },
                Finding: { type: "string" },
                Severity: { type: "string" },
                Condition: { type: "string" },
                Recommendation: { type: "string" },
                organ: { type: "string" },
                specialty: { type: "string" }
              },
              required: ["RuleID", "Finding"]
            },
            routing: {
              type: "object",
              properties: {
                recipient: { type: "string", enum: ["PCP","Ordering Provider","Specialist","Patient"] },
                channel: { type: "string", enum: ["In-Basket","Fax","Letter","Phone","Portal"] },
                templateName: { type: "string" },
                specialist: { type: "string" }
              },
              required: ["recipient","channel"]
            },
            message: {
              type: "object",
              properties: {
                subject: { type: "string" },
                body: { type: "string" }
              },
              required: ["body"]
            },
            rationale: { type: "string" }
          },
          required: ["chosenRule","routing","message"]
        };

        // Compose the prompt
        const system = [
          "You are a clinical navigator assistant.",
          "Given a short radiology report snippet, organization capabilities, PCP status, rules, and templates, you must:",
          "1) Pick the best matching rule (do not hallucinate).",
          "2) Choose routing: recipient + channel. Prefer In-Basket for PCP if on record; else Ordering Provider. If org has the needed specialist, consider Specialist; otherwise fall back to PCP/OP. Use Fax only if org allows.",
          "3) Select an existing template by name when possible; otherwise synthesize text that matches the selected channel and recipient.",
          "4) Produce the final subject/body with {{placeholders}} left intact for PHI fields (pcpName, patientName, mrn).",
          "Return ONLY valid JSON per the provided schema."
        ].join(" ");

        const user = {
          role: "user",
          content:
            `INPUT:\n` +
            `Org: ${task.org.name}\nAllowsFax: ${task.org.allowsFax}\nSpecialists: ${task.org.specialists.join(", ") || "none"}\n` +
            `PCP on record: ${task.pcpOnRecord}\nSnippet: ${task.snippet}\n\n` +
            `RULES JSON:\n${JSON.stringify(task.rules).slice(0, 120000)}\n\n` + // cap large inputs
            `TEMPLATES JSON:\n${JSON.stringify(task.templates).slice(0, 120000)}\n\n` +
            `IMPORTANT: pick from given rules/templates; do not fabricate rule text.`
        };

        const completion = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${env.OPENAI_API_KEY}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "gpt-4o",
            temperature: 0.2,
            response_format: { type: "json_object" },
            messages: [
              { role: "system", content: system },
              user,
              { role: "system", content: `Output schema: ${JSON.stringify(toolSchema)}` }
            ]
          })
        }).then(r => r.json());

        const content = completion?.choices?.[0]?.message?.content || "{}";
        let parsed;
        try { parsed = JSON.parse(content); }
        catch { return bad("Model returned invalid JSON", cors); }

        return json(parsed, cors);
      }

      return new Response("Not found", { status: 404, headers: cors });
    } catch (e) {
      return bad(e?.message || "Server error", {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      });
    }
  }
};

async function getJson(u) {
  const r = await fetch(u, { headers: { "Cache-Control": "no-cache" } });
  if (!r.ok) throw new Error(`Failed to fetch ${u}: ${r.status}`);
  return r.json();
}

function json(obj, extra = {}) {
  return new Response(JSON.stringify(obj, null, 2), {
    headers: { "Content-Type": "application/json; charset=utf-8", ...extra }
  });
}
function bad(msg, extra = {}) {
  return new Response(JSON.stringify({ error: msg }), {
    status: 400,
    headers: { "Content-Type": "application/json; charset=utf-8", ...extra }
  });
}

